# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **Solana-based game** where users operate upgradable "generators" that generate USDC over time. The game revolves around three interconnected loops:

1. **Generator Loop** - Item acquisition and generator upgrades
2. **Generator Runtime Loop** - Daily USDC generation and distribution
3. **Factory Loop** - Token acquisition through mock trading

### Game Economy
- **In-game token**: Custom SPL token (referred to as "$token")
- **In-game currency**: "Balance" (purchased with fiat, used for factory trades)
- **Reward token**: USDC (generated by generators, distributed daily)

Token acquisition methods:
- Buy on DEX (Raydium)
- Buy via factory loop (sometimes cheaper, but requires waiting)

## Project Structure

This is a **Yarn workspace monorepo** containing:

### Workspace Layout
- **Root**: Workspace orchestration with Yarn 4.x, Supabase integration
- **packages/dapp**: Full-stack Solana dApp with React frontend and Anchor program
- **packages/db**: Supabase database package
  - `supabase/migrations/`: Database migrations
  - Supabase JS client wrapper
  - Shared package for DB access across other packages
- **packages/api**: Backend API with Express + TypeScript
  - `src/routes/`: API route handlers
  - `src/services/`: Business logic and service layer
  - `src/config/`: Configuration with Zod validation
  - Transaction verification system implementation
- **Autonomous Runtimes**: Node.js + TypeScript services (location TBD)
  - Generator runtime executor
  - Trade resolver

The `packages/dapp` directory contains:
- **anchor/**: Anchor Solana program (Rust) with IDL, tests, and generated client
- **src/**: React/Vite frontend application
  - **features/**: Feature-based organization (dapp, account, dashboard, cluster)
    - Each feature has `data-access/` and `ui/` subdirectories
  - **components/**: Shared UI components and providers

## Game Mechanics

### 1. Generator Loop
Users manage upgradable generators that produce USDC through a daily runtime process.

**Item System:**
- Items obtained via **gacha system**: burn $token ‚Üí receive random item
- Items can be stored in **inventory** or **equipped** to generator
- Equipped items upgrade generator attributes
- Generators have **slots** for item upgrades

**Progression:**
- XP system for generator upgrades
- Attributes affect runtime performance (flux generation, stability, event probability)

### 2. Generator Runtime Loop
The core USDC generation mechanism that runs daily.

**Daily Cycle:**
- Starts at a **fixed time** (same for all users)
- Generators produce "**flux**" based on their attributes
- Runtime events can occur:
  - Overheat
  - Breakdown
  - Power surge
  - Other events based on generator attributes

**Distribution:**
- At end of day, all flux is pooled
- All USDC acquired is pooled
- **USDC distributed proportionally** based on each user's flux contribution
- Formula: `user_reward = (user_flux / total_flux) * total_usdc_pool`

### 3. Factory Loop
Token acquisition system through simulated trading.

**Flow:**
1. User purchases "**balance**" (in-game currency)
2. Selects a free **trade slot** in their factory
3. Chooses a **trade mode** (different durations, same token rewards)
4. Trade costs X balance
5. Trade simulates a **long position with liquidation line**:
   - If price falls below liquidation line before trade ends ‚Üí **liquidated** (lose balance)
   - If survive entire duration ‚Üí get **balance refund + full tokens**
   - Partial survival ‚Üí get **proportional tokens** (50% time = 50% tokens)
6. All trade modes yield **same amount of tokens**, only duration differs

**Unlocks:**
- Factory has **trade slots** that can be unlocked
- Purchase "**factory-engine**" (abstract name) to enable parallel trades
- More slots = more parallel trades = faster token acquisition

**Progression:**
- XP system for factory upgrades

## Transaction Verification System

A critical component of the game that handles all on-chain token transfers securely. The system ensures transactions are verified on-chain before updating game state, preventing exploits and maintaining economic integrity.

### Overview

All token movements in the game flow through this verification system. It uses a **construct ‚Üí store ‚Üí sign ‚Üí verify ‚Üí update** pattern that maintains security while providing smooth UX.

**Key Principle:** Backend constructs transactions, users sign them, and backend only updates game state after on-chain verification.

### Transaction Types

The game uses **two different tokens** with distinct characteristics:

**SOL (Native Solana Token):**
- Transfers use **System Program** (simplest transfer mechanism)
- Direct wallet-to-wallet transfers (no token accounts needed)
- Lower complexity and fees
- Used for: shop purchases, generator reward claims

**$TOKEN (Custom SPL Token):**
- Uses **Token-2022 standard** (supports transfer tax and minting)
- Requires Associated Token Accounts (ATA)
- More complex instruction structure
- Used for: gacha burns, token rewards

### Four Primary Transaction Flows

1. **User ‚Üí Vault (SOL)** - Shop purchases with native SOL
   - User initiates purchase (buy item, buy balance, etc.)
   - User transfers SOL to vault
   - Backend verifies and credits item/balance

2. **User ‚Üí Dead Address ($TOKEN)** - Burning tokens for gacha rolls
   - User burns tokens to dead address
   - Backend verifies burn and grants pre-rolled item
   - Uses pre-roll approach (see Gacha System below)

3. **Vault ‚Üí User (SOL)** - Claiming daily generator rewards
   - User requests reward claim
   - Backend pre-signs with vault authority
   - User co-signs for fees
   - Backend verifies and updates claim record

4. **Vault ‚Üí User ($TOKEN)** - Issuing token rewards
   - Similar to SOL rewards but using $TOKEN
   - Backend pre-signs, user co-signs
   - Backend verifies and credits tokens

### Core Verification Flow (10 Steps)

This flow applies to ALL transaction types:

1. **User initiates action** via API call
   - Example: `POST /api/shop/purchase-item` with `{itemId: 123}`

2. **Backend validates request**
   - Check user has sufficient balance/tokens
   - Verify requirements are met (item exists, user eligible, etc.)
   - Return early with error if validation fails

3. **Backend constructs unsigned transaction**
   - Build Solana transaction with proper instructions
   - For vault‚Üíuser flows: Backend pre-signs with vault authority
   - Calculate exact amounts, accounts, and instruction data

4. **Backend creates pending transaction record**
   - Insert into `pending_transactions` table
   - Store transaction metadata, unsigned transaction bytes, context data
   - Set 5-minute expiration

5. **Backend returns unsigned transaction to user**
   - Response: `{transactionId: "uuid", unsignedTransaction: "base64..."}`

6. **Frontend: User signs and submits to Solana**
   - Wallet prompts for signature
   - Frontend submits signed transaction to Solana network
   - Receives signature/txid back from Solana

7. **Frontend notifies backend with signature**
   - Call: `POST /api/transactions/{transactionId}/verify`
   - Body: `{signature: "abc123..."}`
   - **No polling needed** - user explicitly notifies backend

8. **Backend verifies transaction on-chain**
   - Fetch transaction from Solana via RPC using signature
   - Verify transaction status is "finalized"
   - Validate transaction structure matches expected:
     - **For SOL**: System Program instruction, correct lamports amount
     - **For $TOKEN**: Token Program instruction, correct token accounts and amounts
     - Correct accounts (user, vault, program IDs)
     - Correct instruction data
     - Matches the original unsigned transaction

9. **Backend updates database atomically**
   - Mark `pending_transactions.status = 'confirmed'`
   - Execute business logic (add item, update balance, etc.)
   - Store `expected_signature` for idempotency
   - All updates in single DB transaction (atomic)

10. **Backend returns success to frontend**
    - User sees confirmation UI

### Gacha System Flow (Pre-roll Approach)

Special handling for "burn token ‚Üí reveal random item" mechanic:

1. **User requests gacha roll** - `POST /api/gacha/purchase`

2. **Backend pre-rolls item result**
   - Generate cryptographically secure random item
   - Store in `pending_transactions.transaction_data`:
     ```json
     {"item_id": 42, "item_rarity": "rare", "cost_amount": 1000}
     ```
   - Construct burn transaction (send $TOKEN to dead address)
   - Return `{transactionId, unsignedTransaction}`

3. **Frontend shows "spinning" animation**
   - User sees loading/anticipation UI
   - Item result is hidden until verification

4. **User signs and submits transaction**

5. **Frontend calls verify endpoint**

6. **Backend verifies burn transaction**
   - Confirms tokens burned to dead address
   - Correct amount burned
   - Transaction finalized

7. **Backend adds pre-rolled item to inventory**
   - Insert into `generator_items` from stored `transaction_data`
   - Mark transaction confirmed

8. **Frontend reveals item with drop animation**
   - "You got a Rare Sword!"

**Why Pre-roll?**
- **Deterministic**: Item locked in when transaction created
- **Idempotent**: Retry verification reveals same item
- **Atomic**: Roll and burn are inseparable
- **Fair**: Can't manipulate randomness after seeing transaction
- **UX**: Smooth reveal animation after confirmation

### Technical Implementation

**Transaction Construction:**

SOL transfers (System Program):
```typescript
// User ‚Üí Vault (Shop Purchase)
SystemProgram.transfer({
  fromPubkey: userWallet,
  toPubkey: vaultWallet,
  lamports: amount, // 1 SOL = 1e9 lamports
})

// Vault ‚Üí User (Reward Claim) - Backend pre-signs
transaction.partialSign(vaultKeypair);
```

$TOKEN transfers (Token Program):
```typescript
// User ‚Üí Dead Address (Gacha Burn)
createTransferInstruction(
  userTokenAccount,    // from ATA
  deadTokenAccount,    // to dead address ATA
  userWallet,          // owner
  burnAmount,          // token amount (with decimals)
  [],
  TOKEN_PROGRAM_ID
)

// Vault ‚Üí User (Token Reward) - Backend pre-signs
transaction.partialSign(vaultAuthorityKeypair);
```

**Key Differences:**

| Aspect | SOL Transfers | $TOKEN Transfers |
|--------|---------------|------------------|
| Program | System Program | Token-2022 Program |
| Accounts | 2 (from, to) | 3+ (from ATA, to ATA, authority) |
| Complexity | Simple | Moderate |
| Fees | ~0.000005 SOL | ~0.00001 SOL + ATA rent |
| Verification | Straightforward | Token account validation required |

### Database Schema

**pending_transactions table** (`packages/db/supabase/migrations/20251112000000_transaction_verification_system.sql`):

```sql
CREATE TABLE pending_transactions (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),

  transaction_type TEXT, -- 'purchase_item', 'gacha_roll', 'claim_rewards', etc.
  status TEXT DEFAULT 'pending', -- 'pending', 'confirmed', 'failed', 'expired'

  expected_signature TEXT, -- filled after verification (idempotency)
  unsigned_transaction TEXT, -- base64 encoded bytes
  transaction_data JSONB, -- context (item_id, amounts, pre-rolled results)

  sol_amount BIGINT, -- lamports (NULL if not SOL transaction)
  token_amount BIGINT, -- tokens with decimals (NULL if not token transaction)

  expires_at TIMESTAMPTZ, -- NOW() + 5 minutes
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
);
```

**Supporting Functions:**
- `expire_old_transactions()` - Mark expired pending transactions (run every 5 min)
- `cleanup_old_transactions(days)` - Delete old confirmed/failed/expired records (prevent bloat)

**RLS Policies:**
- Users can view/create/update their own transactions
- Backend service role bypasses RLS automatically

### API Endpoint Pattern

**Create Transaction:**
```
POST /api/{action}
Body: action-specific parameters
Response: {transactionId, unsignedTransaction}
```

**Verify Transaction:**
```
POST /api/transactions/{transactionId}/verify
Body: {signature: "string"}
Response: {success: true, data: {...}}
```

**Examples:**
- `POST /api/shop/purchase-item` - Buy item with SOL
- `POST /api/gacha/purchase` - Buy gacha roll with $TOKEN
- `POST /api/generator/claim-rewards` - Claim daily SOL rewards
- `POST /api/transactions/{id}/verify` - Universal verification endpoint

### Design Principles

**Security:**
- Always verify on-chain transaction structure
- Never trust user-provided amounts or data
- Validate transaction is finalized before updating state
- Check instruction data matches expected values

**Atomicity:**
- Use database transactions for state updates
- All-or-nothing: verify + update in single transaction
- Rollback if any step fails

**Idempotency:**
- Store `expected_signature` after first verification
- Return cached result if same signature submitted twice
- Prevents double-processing

**User Experience:**
- Immediate verification (no polling delays)
- Clear error messages for failures
- Smooth animations for gacha reveals
- Retry mechanisms for network issues

**Transaction Expiration:**
- Pending transactions expire after 5 minutes
- Prevents replay attacks
- Cleanup job removes expired records
- User can create new transaction if expired

### Implementation Status

**Completed:**
- ‚úÖ Database schema (`pending_transactions` table)
- ‚úÖ Cleanup functions (expire and delete old transactions)
- ‚úÖ RLS policies for user access control

**In Progress:**
- üöß Transaction construction utilities
- üöß Verification service (fetch + validate from Solana)
- üöß API endpoints for each transaction type

**Pending:**
- ‚è≥ Frontend transaction signing flow
- ‚è≥ Gacha reveal UI with animations
- ‚è≥ Error handling and retry logic
- ‚è≥ Edge case testing

For detailed documentation, see: `docs/TRANSACTIONS_FEATURE.md`

## Common Commands

### Development Workflow
```bash
# From packages/dapp directory:
npm run dev                # Start Vite dev server
npm run anchor-localnet    # Start local validator with program deployed
npm run anchor-test        # Run Anchor tests

# CI/Build
npm run build              # TypeScript compile + Vite build
npm run lint               # ESLint
npm run format             # Prettier format
npm run format:check       # Prettier check
npm run ci                 # Full CI: build + lint + format check + codama
```

### Anchor Program
```bash
# Initial setup - sync program keys and generate client
npm run setup              # Runs: anchor keys sync && codama:js

# Individual commands
npm run anchor-build       # Build the Anchor program
npm run anchor keys sync   # Sync program ID across config and code
npm run codama:js          # Generate JS SDK from IDL using codama

# Deploy
npm run anchor deploy --provider.cluster devnet
```

Note: All Anchor commands can be run from packages/dapp using `npm run anchor <command>` or from `packages/dapp/anchor` using `anchor <command>` directly.

## Architecture

### Tech Stack
- **Frontend**: React 19, Vite, TypeScript, React Router 7
  - **Solana SDK**: [Gill](https://gill.site/) (modern Solana SDK)
  - **Wallet Integration**: @wallet-ui/react with Gill adapter
  - **State Management**: TanStack Query (@tanstack/react-query) + Jotai
  - **Styling**: Tailwind CSS 4, Shadcn UI components
- **Backend API**: Express + TypeScript
- **Database**: Supabase (hosted)
  - Migrations in `packages/db/supabase/migrations`
  - Supabase JS client for database access
  - Realtime subscriptions for autonomous runtimes
- **On-chain**: Anchor framework (Rust)
- **Client Generation**: Codama (generates TypeScript SDK from Anchor IDL)
- **Autonomous Services**: Node.js + TypeScript
  - Generator runtime executor (runs daily cycles)
  - Trade resolver (resolves factory trades)

### System Architecture

**Client ‚Üí Backend ‚Üí Database ‚Üí Blockchain**

1. **Frontend (React + Gill)**
   - User interactions and wallet connections
   - Solana transactions via Gill SDK
   - API calls to Express backend
   - Direct database queries via Supabase client (for read-heavy operations)

2. **Backend API (Express + TypeScript)**
   - REST endpoints for game logic
   - User authentication and authorization
   - Database access via Supabase client
   - Solana program interactions via Anchor/Codama generated clients

3. **Database (Supabase)**
   - PostgreSQL database for game state
   - User data, generators, items, inventory, trades
   - Realtime subscriptions for triggering autonomous services

4. **Autonomous Runtimes (Node.js + TypeScript)**
   - **Generator Runtime Executor**:
     - Subscribes to Supabase realtime events
     - Runs daily at fixed time
     - Calculates flux generation for each user
     - Handles runtime events (overheat, breakdown, power surge)
     - Distributes USDC proportionally at end of day
   - **Trade Resolver**:
     - Monitors active trades via realtime subscriptions
     - Tracks price movements against liquidation lines
     - Resolves trades (liquidated vs. survived)
     - Calculates token rewards based on survival time
     - Updates user balance and token holdings

5. **Blockchain (Solana)**
   - Custom SPL token program
   - Generator on-chain state (if applicable)
   - USDC transfers
   - Item NFTs (if applicable)

### Provider Hierarchy
App providers wrap the application in this order (outermost to innermost):
1. `ReactQueryProvider` - TanStack Query for data fetching
2. `ThemeProvider` - Theme management (next-themes)
3. `SolanaProvider` - Wallet UI + Gill integration
   - Configures clusters (localnet, devnet)
   - Wraps children with `WalletUiGillProvider`

### Feature Organization Pattern
Features follow a consistent structure:
- **{feature}-feature.tsx**: Main feature component
- **data-access/**: React Query hooks and mutations
  - `use-{action}-mutation.ts`: Mutations (write operations)
  - `use-get-{resource}-query.ts`: Queries (read operations)
  - `use-invalidate-get-{resource}-query.ts`: Query invalidation helpers
  - `use-get-{resource}-query-key.ts`: Query key factories
- **ui/**: Presentational components
  - `{feature}-ui-{component}.tsx`: UI components

### Anchor to Frontend Flow
1. Write Anchor program in `anchor/programs/dapp/src/lib.rs`
2. Build program: `npm run anchor-build` (generates IDL in `anchor/target/idl/`)
3. Sync program ID: `npm run anchor keys sync` (updates `Anchor.toml`, `lib.rs`, and `dapp-exports.ts`)
4. Generate client: `npm run codama:js` (uses `anchor/codama.js` config to generate TypeScript SDK in `anchor/src/client/js/generated/`)
5. Export from `anchor/src/dapp-exports.ts` for use in React components
6. Create data-access hooks in `src/features/{feature}/data-access/`
7. Build UI components in `src/features/{feature}/ui/`

### Codama Configuration
The `anchor/codama.js` file uses a temporary workaround for a Gill issue (see comment in file). It configures:
- IDL input path: `target/idl/dapp.json`
- Client output path: `anchor/src/client/js/generated`

### Current Anchor Program
The example program (`packages/dapp/anchor/programs/dapp/src/lib.rs`) implements a simple "greet" instruction that logs "GM!" on-chain. Program ID: `JAVuBXeBZqXNtS73azhBDAoYaaAFfo4gWXoZe2e7Jf8H`

**Note:** This is a template program and will be replaced with actual game logic for:
- SPL token minting/burning (gacha system)
- Generator state management
- Item inventory and equipment
- USDC distribution
- Factory trade mechanics

## Routes (Planned)

### Current (Template)
- `/` - Dashboard
- `/account` - Account list
- `/account/:address` - Account detail
- `/dapp` - Interact with the Anchor program

### Future (Game Features)
- `/` or `/dashboard` - Main dashboard
- `/generator` - Generator management and upgrades
  - View current generator state
  - Equip/unequip items
  - Manage inventory
  - Gacha system interface
- `/generator/runtime` - Real-time generator runtime monitoring
  - View flux generation
  - Monitor events (overheat, breakdown, power surge)
  - Track daily progress
- `/factory` - Factory/trading interface
  - Purchase balance
  - Select trade slots
  - Choose trade modes
  - Monitor active trades
- `/factory/history` - Trade history and results
- `/inventory` - Item inventory management
- `/leaderboard` - Flux generation rankings
- `/wallet` or `/account/:address` - Wallet management and USDC balances

## Database Schema Considerations

Key entities with database tables:

**Implemented:**
- **pending_transactions**: Transaction verification system records (see Transaction Verification System section)

**Planned:**
- **Users**: Wallet address, XP, stats
- **Generators**: Per-user generator state, attributes, equipped items
- **Items**: Item definitions (types, rarities, attributes)
- **Inventory**: User-owned items (equipped vs. in storage)
- **Generator Runtimes**: Daily runtime records, flux generated, events
- **Trades**: Active and completed factory trades
- **Balances**: User in-game currency balances
- **Token Transactions**: History of $token burns, rewards (may be consolidated with pending_transactions)
- **USDC Distributions**: Daily USDC distribution records

## Development Workflow Notes

### Adding New Game Features
1. **Define database schema** in `packages/db/supabase/migrations`
2. **Create/update Anchor programs** for on-chain logic
3. **Build Anchor program** and generate TypeScript client with Codama
4. **Implement backend API endpoints** in Express
5. **Create React feature** following the feature organization pattern:
   - `{feature}-feature.tsx` - Main component
   - `data-access/` - React Query hooks
   - `ui/` - UI components
6. **Add route** to `app-routes.tsx`

### Working with Autonomous Runtimes
- Runtimes use Supabase realtime subscriptions as event triggers
- Ensure database changes emit proper events for runtime triggers
- Test runtimes independently before integrating with main app
- Consider using separate deployment/scaling for autonomous services
